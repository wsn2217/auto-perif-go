# ðŸ“„ Specification for converting natural language to PDL language


# Rules for Translating Natural Language Security Protocols to Formal Specification
# Global Generation Rules
- é™¤ä¿ç•™å…³é”®å­—å¤–ï¼Œæ‰€æœ‰å˜é‡ã€å‡½æ•°ã€å¸¸é‡å‘½åä¸€å¾‹ç¦æ­¢ä½¿ç”¨ä¸‹åˆ’çº¿ï¼›åŠ å¯†é¡¹ä¸­ä¹Ÿä¸è¦å‡ºçŽ°ä¸‹åˆ’çº¿ç¬¦å·ã€‚


## 1. Protocol Name and Roles

* **Rule:** Declare a concise, descriptive name for the protocol and explicitly list all participating roles with brief identifiers (e.g., `A`, `B`, `S`) and optional descriptions.

* **Formal Syntax:**

  ```markdown
  #### Protocol Name
  [ProtocolName]
  
  #### Role
  [Role_Identifier]: [Brief_Description]
  [Role_Identifier]: [Brief_Description]
  ...
  ```

* **Example (Yahalom):**

  ```markdown
  #### Protocol Name
  Yahalom
  
  #### Role
  A: The initiator, client
  B: The responder, server
  S: Trusted Key Distribution Center (KDC)
  ```

## 2. Variable Declarations

* **Rule:** Declare all variables used in the protocol, specifying their type and freshness attribute.

  *   `fresh`: Indicates a value (like a nonce or session key) is newly generated by a role and should be unpredictable.
  *   `var`: Indicates a value is received by a role (typically bound from a received message).
  *   The freshkeyword is used to declare a variable when the role generates a new value (e.g., a nonce, session key, or timestamp). This value must be fresh to ensure security properties such as resistance to replay attacks.
  *   If a variable is used to receive a value from another role (i.e., it is not generated by the current role), it should be declared using var.
      Long-term keys or constants do not require the freshmodifier, as they are not newly generated for each protocol session.
  *   Common types include `Nonce`, `SessionKey`.

* **Formal Syntax:**

  ```markdown
  #### Variable
  fresh [VariableName]: [Type];
  var [VariableName]: [Type];
  ...
  ```

* **Example (Yahalom):**

  ```markdown
  #### Variable
  fresh Na: Nonce;
  fresh Nb: Nonce;
  var Kab: SessionKey;
  ```

## 3. Protocol Steps (`defines` block)

* **Rule:** Define the sequence of message exchanges within a `defines { ... }` block. Each message follows the structure: `Sending_Role -> Receiving_Role: Message_Content;`.

  *   **Message Content:** Use cryptographic notation clearly:
      *   `A, B` represents concatenation of plaintext elements.
      *   `{MessageContent}Key` represents `MessageContent` encrypted with `Key`.
      *   `H(Content)` represents a hash operation (requires prior `hashfunction` declaration).

* **Formal Syntax:**

  ```markdown
  ### Protocol steps
  defines {
      [Role1] -> [Role2]: [Message1];
      [Role2] -> [Role3]: [Message2];
      ...
  }
  ```

* **Example (Yahalom):**

  ```markdown
  ### Protocol steps
  defines {
      A -> B: A, Na;
      B -> S: B, {A, Na, Nb}k(B,S);
      S -> A: {B, Kab, Na, Nb}k(A,S), {A, Kab}k(B,S);
      A -> B: {A, Kab}k(B,S), {Nb}Kab;
  }
  ```

## 4. Security Goals (`goals` or `claims` block)

* **Rule:** Declare the security properties the protocol is intended to achieve within a `goals { ... }` or `claims { ... }` block. These are statements for formal verification tools to check.

* **Common Claim Types:**

  *   `Authenticates(R1, R2, [Parameters])`: Role R1 authenticates role R2 (possibly on specific parameters like a key).
  *   `Secret(Term)`: The `Term` (e.g., a key) remains confidential.
  *   `Alive(R)`: Role R has participated in the protocol (is alive).
  *   `Weakagree(R1, R2)`: Roles R1 and R2 achieve weak agreement.
  *   `Niagree(R1, R2)`: Roles R1 and R2 achieve non-injective agreement (stronger authentication).
  *   `Nisynch(R1, R2)`: Roles R1 and R2 achieve non-injective synchronization.

* **Formal Syntax:**

  ```markdown
  ### Security Goals
  goals {
      [Claim1];
      [Claim2];
      ...
  }
  ```

* **Example (Yahalom):**

  ```markdown
  ### Security Goals
  goals {
      Authenticates(B, A, [Kab]);
      Authenticates(A, B, [Kab]);
      Secret(Kab);
      Alive(A);
      Alive(B);
      Weakagree(A, B);
  }
  ```



