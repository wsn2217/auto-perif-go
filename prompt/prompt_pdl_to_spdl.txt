You are a security protocol expert tasked with converting protocols from PDL (Protocol Description Language) format to SPDL (Scyther Protocol Description Language) format.

# SPDL Conversion Specifications

Fill in each field to generate a valid SPDL protocol.

---
## 1. Global Declarations

### Global Type Declarations

#### Syntax Rules
**Rule:** Global types are declared using the `usertype` keyword followed by the type name, terminated with a semicolon.

**Formal Syntax:**
```scyther
usertype {{TypeName}};
```

**Purpose:** Declares a new type called <TypeName>. This type is unique within the protocol and cannot be confused with other types. The usertype keyword allows you to define protocol-specific data types, extending Scyther's built-in type system. It enables the creation of distinct types to prevent mixing with existing types.

### Examples
```scyther
usertype Certificate;      // Defines a certificate type
usertype Biometric;        // Defines a biometric data type  
usertype HardwareToken;    // Defines a hardware token type
usertype SessionKey;       // Defines a session key type
```

### Global Function Declarations

#### Syntax Rules
**Rule:** Global functions are declared using the `const` keyword followed by the function name, a colon, the `Function` type specifier, terminated with a semicolon.
If the function is hash function, it can be defined using a global declaration `hashfunction`, such as `hashfunction H`. The expression H(m)denotes the application of hash function `H` to message `m`.

**Formal Syntax:**
```scyther
const {{FunctionName}}: Function;
hashfunction H;
```

**Purpose:** Declares functions that can be applied to arguments within protocol operations. Functions typically represent cryptographic operations, transformations, or value generators.

#### Examples
```scyther
const succ: Function;        // Successor function (e.g., for sequence numbers)
const Fresh: Function;      // Fresh value generator
hashfunction H;             // A hash function H
```

### Complete Declaration Section Example

#### Typical Scyther File Structure
```scyther
// ===== GLOBAL DECLARATIONS SECTION =====
// Type declarations
usertype SessionKey;

// Function declarations  
const succ: Function;
const Fresh: Function;
hashfunction H;

// ===== PROTOCOL DEFINITION SECTION =====
protocol example(A, B, S)
{
    // Protocol roles and logic using the declared types and functions
    role A {
        fresh na: Nonce;
        // ... protocol steps
    }
}
```

#### Real-World Example (Andrew Secure RPC Protocol)
```scyther
// Type declarations
usertype SessionKey;

// Function declarations
const succ: Function;
const Fresh: Function;

protocol yahalom(A, B, S) 
{
    role A {
        fresh nA: Nonce;
        var nB,nB2: Nonce;
        var kab: SessionKey;

        send_1(A,B, A,{nA}k(A,B) );
        recv_2(R,A, {succ(nA),nB}k(A,B) );
       // ... other steps
    }
    // ... other roles
}
```
---

## 2. Protocol Metadata

* **Protocol Name:** `{{PROTOCOLNAME}}`
* **Protocol ID:** `{{PROTOCOLID}}`
* **Version:** `1.0`
* **Authentication Type:** `{{AUTH_TYPE}}` *(mutual / unilateral)*

---
## 3. Cryptographic Primitives
**Encryption and decryption**:The symmetric key between participants X and Y is denoted by k(X,Y), representing a long-term shared key. Symmetric encryption of a message m with the shared key k(X,Y) is expressed as {m} k(X,Y).
The public key of participant X is denoted by pk(X), and the private key is denoted by sk(X). Public key encryption of a message m with the public key of X is expressed as {m} pk(X). Similarly, decryption with the private key of X is expressed as {m}sk(X).

## 4. Role Definitions

### Role 1: `{{ROLE_1}}`

* **Challenge (fresh):** `{{CHALLENGE}} : Nonce`
* **Custom Variable:** `{{Variable_Name}} : {{NEW_TYPE}}`
* **Session Key Variable:** `{{Session_Key}} : SessionKey`

#### Authentication Sequence

 **Send (Step 1):** `send_!1({{Sender}}, {{Receiver}}, {{Message}});`
 **Receive (Step 2):** `recv_!2({{Sender}}, {{Receiver}}, {{Message}});`

#### Security Claims

* `claim_{{ROLE_1}}1({{ROLE_1}}, Niagree);`
* `claim_{{ROLE_1}}2({{ROLE_1}}, Nisynch);`
* `claim_{{ROLE_1}}3({{ROLE_1}}, Secret, {{Session_Key}});`

---

### Role 2: `{{ROLE_2}}`

* **Challenge Variable:** `{{CHALLENGE}} : Nonce`
* **Session Key Variable:** `{{Session_Key}} : SessionKey`
* **Response (fresh):** `{{RESPONSE}} : Nonce`

#### Authentication Sequence

 **Receive (Step 1):** `recv_1({{Sender}}, {{Receiver}}, {{Message}});`
 **Send (Step 2):** `send_2({{Sender}}, {{Receiver}}, {{Message}});`

#### Security Claims

* `claim_{{ROLE_2}}1({{ROLE_2}}, Running, {{ROLE_1}}, {{CHALLENGE}}, {{RESPONSE}});`
* `claim_{{ROLE_2}}2({{ROLE_2}}, Secret, {{Session_Key}});`

---

## 5. Claims Syntax Specification


### Overview of Claims in Scyther

In Scyther, `claim` statements are used to **declare the security properties** that a protocol is expected to satisfy. These claims are verified by Scyther's formal verification engine to determine if the protocol maintains these properties under various attack models .

Claims are typically placed within **role definitions** and specify the security goals that role aims to achieve upon successful protocol execution .

### Basic Claim Syntax

The fundamental syntax for a claim statement is:

```scyther
claim(Role, ClaimType, [Parameters]);
```

*   **`Role`**: The name of the role making the claim (e.g., `A`, `B`, `S`, `I`, `R`).
*   **`ClaimType`**: The type of security property being claimed (e.g., `Secret`, `Alive`, `Nisynch`).
*   **`Parameters`** (Optional): Terms relevant to the claim, such as messages, keys, or nonces. Required for some claim types (e.g., `Secret`, `Fresh`) and omitted for others (e.g., `Alive`, `Nisynch`) .

### Common Claim Types and Their Meanings

Scyther supports a range of security properties. Here are the most common claim types :

| Claim Type | Meaning & Purpose | Example Syntax |
| :--- | :--- | :--- |
| **`Secret`** | Declares that a **term** (e.g., a key, nonce) is **confidential** and known only to trusted parties. | `claim(A, Secret, Kab);` |
| **`Alive`** | Declares that role **A is alive**, meaning it has participated in some part of the protocol (though not necessarily in full synchrony with another specific role). | `claim(A, Alive);` |
| **`Weakagree`** | Declares that role **A weakly agrees** with B, meaning if B exists, then A did interact with *some* instance of B. | `claim(A, Weakagree);` |
| **`Niagree`** (Non-injective agreement) | Declares that role **A non-injective agrees** with B on a set of data. This means A believes it is communicating with B, but the protocol run might not be fresh (replay attacks are possible). | `claim(A, Niagree);` |
| **`Nisynch`** (Non-injective synchronisation) | Declares that the protocol run is **synchronised** for roles A and B (messages are in the correct order), but it might not be fresh. | `claim(A, Nisynch);` |
| **`Commit`** | Declares that role **A commits** to role B regarding a specific term, often used to represent a commitment to a value. | `claim(A, Commit, B, Na);` |
| **`Empty`** | Declares when Scyther is used as a back-end for other verification means. | `claim(A, Empty, (Fresh,kab));` |
| **`SKR`** (Session Key Reveal) | Similar to `Secret`, but specifically within a session-key reveal attack model where the adversary can reveal session keys . | `claim(A, SKR, Kab);` |
| **`Reachable`** | Used to check if a particular state or claim is reachable during the protocol analysis . | `claim(A, Reachable);` |

### Usage Rules and Best Practices

**Placement within Role Definitions**: Claims are usually placed **inside the definition of a role**, after all the protocol steps (`send`, `recv` events), to specify the security goals for that role after completing its part of the protocol interaction .
    ```scyther
    role A {
        fresh Na: Nonce;
        var Nb: Nonce;
     

        send_1(A, B, {A,Na}k(A,B));
        recv_2(B, A, {Nb}k(A,B));
        send_3(A, B, {Nb}k(A,B));

        // Security claims for role A
        claim_A1(A, Secret, Na);
        claim_A2(A, Secret, Nb);
        claim_A3(A, Nisynch);
        claim_A4(A, Niagree);
    }
    ```
**Combining Claims**: A protocol typically employs **multiple `claim` statements** to verify that it satisfies various security properties. For example, an authenticated key exchange protocol might claim `Secret` (key confidentiality), `Niagree` or `Nisynch` (entity authentication and synchronization), and `Weakagree` (authentication) .
**Parameter Dependence**: Some claim types (like `Secret`, `Commit`, `Weakagree`) require specifying parameters (e.g., the key or nonce in question), while others (like `Alive`, `Nisynch`) do not.
---

## 6.Receive and send events
The recv and send events mark receiving and sending a message, respectively. send(transmit) and recv(receive) operations are identified by globally unique labels (Labels) to enforce protocol execution order and message correspondence. Labels must adhere to the following core rules:

* Global Uniqueness: All send_X and recv_X labels (e.g., 1, 2, 3) are unique across the entire protocol (no duplicates).
* Message Matching: The label of a send_X operation must exactly match the label of its corresponding recv_X opertion to ensure ordered message delivery.
* Phase Sequencing: Labels are assigned in strictly increasing order (e.g., 1→ 2→ 3→ 4) to reflect the chronological flow of message exchanges.

---
## 7. Protocol Form (Fillable SPDL Skeleton)

```spdl
usertype {{TypeName}};     // Type declarations
const {{FunctionName}}: Function;   // Function declarations


protocol {{Protocol Name}}({{ROLE_1}}, {{ROLE_2}}{{OPTIONAL_ROLES}}) {

  role {{ROLE_1}} {
    fresh {{CHALLENGE}}: Nonce;
    var {{Variable_Name1}}: {{NEW_TYPE}};
    var {{Variable_Name2}}: TypeName;

    send_1({{Sender}}, {{Receiver}}, {{Message}});
    recv_2({{Sender}}, {{Receiver}}, {{Message}});

    claim_{{ROLE_1}}1({{ROLE_1}}, Niagree);
    claim_{{ROLE_1}}2({{ROLE_1}}, Nisynch);
    claim_{{ROLE_1}}3({{ROLE_1}}, Secret, {{Session_Key}});
  }

  role {{ROLE_2}} {
    var {{CHALLENGE}}: Nonce;
    var {{Session_Key}}: SessionKey;
    fresh {{RESPONSE}}: Nonce;

    recv_1({{Sender}}, {{Receiver}}, {{Message}});
    send_2({{Sender}}, {{Receiver}}, {{Message}});

    claim_{{ROLE_2}}1({{ROLE_2}}, Running, {{ROLE_1}}, {{CHALLENGE}}, {{RESPONSE}});
    claim_{{ROLE_2}}2({{ROLE_2}}, Secret, {{Session_Key}});
  }
}
```

## 7.Sample Implementation
### Example 1-Yahalom Protocol
usertype SessionKey;

protocol yahalom(I,R,S)
{
    role I
    {
        fresh Ni: Nonce;
        var Nr: Nonce;
        var T: Ticket;
        var Kir: SessionKey;

        send_1(I,R, I,Ni);
        recv_3(S,I, {R,Kir,Ni,Nr}k(I,S), T );
        send_4(I,R, T, {Nr}Kir );

        claim_I1(I, Secret,Kir);
    }

    role R
    {
        fresh Nr: Nonce;
        var Ni: Nonce;
        var T: Ticket;
        var Kir: SessionKey;

        recv_1(I,R, I,Ni);
        send_2(R,S, R, {I,Ni,Nr}k(R,S) );
        recv_4(I,R, {I,Kir}k(R,S) , {Nr}Kir );

        claim_R1(R, Secret,Kir);
    }

    role S
    {
        fresh Kir: SessionKey;
        var Ni,Nr: Nonce;

        recv_2(R,S, R, {I,Ni,Nr}k(R,S) );
        send_3(S,I, {R,Kir,Ni,Nr}k(I,S), {I,Kir}k(R,S) );

        claim(S, Secret, Ni);
        claim(S, Secret, Nr);
    }
}


### Example 2-Andrew Secure RPC
**Modelled after the description in the SPORE library**
**http://www.lsv.ens-cachan.fr/spore/andrew.html**

**Note:**
**The shared key between I and R is modelled as k(I,R) currently**
**there is no way to express that this key is equal to k(R,I)**
**So it is possile that certain attacks that use this property are not found**

usertype SessionKey;
const succ: Function;
const Fresh: Function;

protocol andrew(I,R)
{
    role I
    {
        fresh ni: Nonce;
        var nr,nr2: Nonce;
        var kir: SessionKey;

        send_1(I,R, I,{ni}k(I,R) );
        recv_2(R,I, {succ(ni),nr}k(I,R) );
        send_3(I,R, {succ(nr)}k(I,R) );
        recv_4(R,I, {kir,nr2}k(I,R) );
        claim_I1(I,Secret,kir);
        claim_I2(I,Nisynch);
        claim_I3(I,Niagree);
        claim_I4(I,Empty,(Fresh,kir));
    }    
    
    role R
    {
        var ni: Nonce;
        fresh nr,nr2: Nonce;
        fresh kir: SessionKey;

        recv_1(I,R, I,{ni}k(I,R) );
        send_2(R,I, {succ(ni),nr}k(I,R) );
        recv_3(I,R, {succ(nr)}k(I,R) );
        send_4(R,I, {kir,nr2}k(I,R) );
        claim_R1(R,Secret,kir);
        claim_R2(R,Nisynch);
        claim_R3(R,Niagree);
        claim_R4(R,Empty,(Fresh,kir));
    }
}

# Note
##1. Output only SPDL code without any additional explanations, comments, or text
##2. Maintain semantic integrity of the protocol
##3. Correctly convert all roles, messages, declarations, and properties
##4. Use Scyther-supported syntax and keywords
##5. Specification: Role definitions should not include constant declarations. The following content should be deleted:
        const A: Agent;
        const B: Agent;
        const S: Agent;
##6. Specification: Define according to the protocol, avoid using -1:
        Incorrect example: {Nb-1}; Correct should be: {subtraction(Nb)} ,where subtraction is a  function.
##7. Protocol names, variable names, and function names must not contain underscore characters ('_').
      Formal Specification:
      Protocol Names:​ Must use PascalCase or camelCase without underscores
      Variable Names:​ Must use camelCase without underscores
      Function Names:​ Must use camelCase without underscores
      Allowed Characters:​ Letters (a-z, A-Z) and digits (0-9), with digits not permitted as the first character
Notice:| **`Niagree`** (Non-injective agreement) | Declares that role **A non-injective agrees** with B on a set of data. This means A believes it is communicating with B, but the protocol run might not be fresh (replay attacks are possible). | `claim(A, Niagree);` |

Now convert the following PDL protocol to SPDL format, output only SPDL code: